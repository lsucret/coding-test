
https://school.programmers.co.kr/learn/courses/30/lessons/172927

## 풀이
피로도를 최소로 하려면 **“힘든 구간에 좋은 곡괭이”**를 쓰는 그리디 문제

그리디 알고리즘은 “그 순간 가장 좋아 보이는 선택만 계속해서 하는 알고리즘”

한번 한 선택은 되돌리지 않고, 미래에 어떤 영향이 있을지 따지지 않음.

매 단계마다 현재 기준 이득이 되는 선택지를 고르는 방식

예시: 동전 거스름돈

핵심 아이디어
- 곡괭이 하나로 광물 최대 5개씩만 캘 수 있으니, minerals를 앞에서부터 5개씩 끊어서 “구간”으로 본다.
- 각 구간마다 “구간 난이도”를 정의해서, 난이도가 높은 구간에 다이아몬드 곡괭이, 그 다음에 철, 마지막에 돌을 배치한다.
- 난이도는 “가장 안 좋은 곡괭이(돌)”로 캤을 때 드는 피로도로 계산하면 정렬 기준으로 쓰기 좋다.

```java
import java.ut이
```java
import java.util.*;

class Solution {
    static class Section {
        int dia;
        int iron;
        int stone;
        int score; // 돌 곡괭이로 캤을 때 피로도

        Section(int dia, int iron, int stone) {
            this.dia = dia;
            this.iron = iron;
            this.stone = stone;
            this.score = dia * 25 + iron * 5 + stone * 1;
        }
    }

    public int solution(int[] picks, String[] minerals) {
        int totalPicks = picks[0] + picks[1] + picks[2];
        int len = Math.min(minerals.length, totalPicks * 5);

        List<Section> sections = new ArrayList<>();

        for (int i = 0; i < len; i += 5) {
            int dia = 0, iron = 0, stone = 0;
            for (int j = i; j < i + 5 && j < len; j++) {
                String m = minerals[j];
                if (m.equals("diamond")) dia++;
                else if (m.equals("iron")) iron++;
                else stone++;
            }
            sections.add(new Section(dia, iron, stone));
        }

        // 난이도 높은 구간부터
        sections.sort((a, b) -> b.score - a.score);

        int answer = 0;
        int idx = 0;

        // 다이아 곡괭이
        for (; idx < sections.size() && picks[0] > 0; idx++, picks[0]--) {
            Section s = sections.get(idx);
            answer += s.dia * 1 + s.iron * 1 + s.stone * 1;
        }

        // 철 곡괭이
        for (; idx < sections.size() && picks[1] > 0; idx++, picks[1]--) {
            Section s = sections.get(idx);
            answer += s.dia * 5 + s.iron * 1 + s.stone * 1;
        }

        // 돌 곡괭이
        for (; idx < sections.size() && picks[2] > 0; idx++, picks[2]--) {
            Section s = sections.get(idx);
            answer += s.dia * 25 + s.iron * 5 + s.stone * 1;
        }

        return answer;
    }
}

```

<img width="300" height="679" alt="image" src="https://github.com/user-attachments/assets/8b16d70f-a9a4-41b0-b0c8-b5c221cab749" />
